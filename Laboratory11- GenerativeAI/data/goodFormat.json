
  [
    {
    "type": "String",
    "specifications": "Determine the last (alphabetically) word in a text containing multiple words separated by spaces\nparams: text (string)\nreturns: last word (string)",
    "code": "def last_word_in_alphabetical_order_by_me(text: str):\n    if not len(text):\n        raise AttributeError(\"Text is empty!\\n\")\n    parsed_text = text.split(' ')\n    last_word: str = parsed_text[0]\n    parsed_text = parsed_text[1:]\n    for word in parsed_text:\n        if word > last_word:\n            last_word = word\n    return last_word\n\ndef last_word_in_alphabetical_order_by_copilot(text: str):\n    \"\"\"\n       Găsește ultimul cuvânt (din punct de vedere alfabetic) dintr-un text.\n\n       Args:\n           text (str): Textul de analizat.\n\n       Returns:\n           str: Ultimul cuvânt alfabetic din text.\n\n       Time Complexity:\n           O(n*log(n)) - Sortarea cuvintelor.\n\n       Space Complexity:\n           O(n) - Spațiu suplimentar pentru lista de cuvinte.\n\n       Example:\n           >>> last_word_in_alphabetical_order_by_copilot(\"Ana are mere rosii si galbene\")\n           'si'\n       \"\"\"\n    cuvinte = text.split()  # Descompunerea textului în cuvinte\n    cuvinte.sort()  # Sortarea cuvintelor în ordine alfabetică\n    return cuvinte[-1]  # Ultimul cuvânt din lista sortată\n\ndef last_word_in_alphabetical_order_by_gpt(text: str):\n    '''\n     Returns the last (alphabetically) word that can appear in the text.\n\n     :param text: A string containing multiple words separated by spaces.\n     :return: The last (alphabetically) word in the text.\n     :time complexity: O(n*log(n)), where n is the number of words in the text.\n     :space complexity: O(n), where n is the number of words in the text.\n     '''\n\n    words = text.split()  # Split the text into individual words\n    words.sort()  # Sort the words alphabetically\n    return words[-1]  # Return the last (alphabetically) word\n\ndef test_last_word():\n    assert (last_word_in_alphabetical_order_by_me(\"Ana are mere rosii si galbene\") == \"si\")\n    assert (last_word_in_alphabetical_order_by_me(\"A B C D E Z H\") == \"Z\")\n    assert (last_word_in_alphabetical_order_by_me(\"A BC D ZJA ZT Z\") == \"ZT\")"
}
,
    {
    "type": "Math",
    "specifications": "Calculate the Euclidean distance between two points\nparams: two tuples representing the coordinates of the points\nreturns: Euclidean distance (float)",
    "code": "def compare_real_numbers(a, b):\n    '''\n    Functie care compara doua numere reale\n    :param a:  primul numar real\n    :param b: al doilea numar real\n    :return:\n    '''\n    if abs(a - b) < 0.000000001:\n        return True\n    return False\n\n#Să se determine distanța Euclideană între două locații\n# identificate prin perechi de numere. De ex. distanța între\n# (1,5) și (4,1) este 5.0\n\ndef problema_2(first_location: tuple, second_location: tuple) -> float:\n    \"\"\"\n    Calculeaza distanta Euclidiana dintre doua locatii\n    :param first_location: prima pereche de coordonate\n    :param second_location:a doua pereche de coordonate\n    :time_complexity: O(1)\n    :space_complexity:O(1)\n    :return:distanta euclideana dintre doua locatii\n    \"\"\"\n    # distanta euclediana\n    distance = (\n        (first_location[0]-second_location[0])**2+(first_location[1]-second_location[1])**2)**(1/2)\n    return distance\n\n\ndef test_problema_2():\n    assert (compare_real_numbers(problema_2((1, 5), (4, 1)), 5.0))\n    assert (problema_2((1, 1), (1, 1)) == 0)\n    assert (compare_real_numbers(problema_2((1, 2, 3), (1, 4, 6)), 13 ** (1 / 2)))\n\nimport math\n\ndef problema_2_gpt(loc1, loc2):\n    '''\n    Returns the Euclidean distance between two locations identified by pairs of numbers.\n\n    :param loc1: A tuple representing the coordinates of the first location (x1, y1).\n    :param loc2: A tuple representing the coordinates of the second location (x2, y2).\n    :return: The Euclidean distance between the two locations.\n    :time complexity: O(1).\n    :space complexity: O(1).\n    '''\n\n    # Unpack the coordinates\n    x1, y1 = loc1\n    x2, y2 = loc2\n\n    # Calculate the Euclidean distance\n    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return distance\nimport math\n\ndef problema_2_copilot(point1, point2):\n    \"\"\"\n    Calculează distanța Euclidiană între două puncte.\n\n    Args:\n        point1 (tuple): Coordonatele primului punct (x1, y1).\n        point2 (tuple): Coordonatele celui de-al doilea punct (x2, y2).\n\n    Returns:\n        float: Distanța Euclidiană între cele două puncte.\n\n    Time Complexity:\n        O(1) - Calculul distanței se face într-un singur pas.\n\n    Space Complexity:\n        O(1) - Nu se folosește spațiu suplimentar.\n\n    Example:\n        >>> euclidean_distance((1, 5), (4, 1))\n        5.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    squared_distance = (x2 - x1) ** 2 + (y2 - y1) ** 2\n    return math.sqrt(squared_distance)"
},
{
    "type": "Math",
    "specifications": "Calculate the dot product of two sparse vectors\nparams: two lists of real numbers\nreturns: dot product (float)",
    "code": "def problema_3(vector1: list, vector2: list) -> float:\n    \"\"\"\n    Determinarea produsului scalar dintre do vectori\n    :param vector1: primul vector rar\n    :param vector2: al doilea vector rar\n    :time_complexity: O(n)\n    :space_complexity: O(1)\n    :return: float - produsul scalar\n            exceptie- daca vectorii nu au lungimi egale\n    \"\"\"\n    if len(vector1) != len(vector2):\n        raise ValueError(\"Vectorii nu au lungimi egale!\")\n    rezultat = 0\n    for i in range(0, len(vector1)):\n        rezultat += vector1[i] * vector2[i]\n    return rezultat\n\n\n# copilot\ndef sparse_scalar_product(vector1, vector2):\n    \"\"\"\n    Calculează produsul scalar al doi vectori rari.\n\n    Args:\n        vector1 (List[float]): Primul vector rar.\n        vector2 (List[float]): Al doilea vector rar.\n\n    Returns:\n        float: Produsul scalar al celor doi vectori.\n\n    Time Complexity:\n        O(n) - Parcurgem doar elementele nenule din vectori.\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> sparse_scalar_product([1, 0, 2, 0, 3], [1, 2, 0, 3, 1])\n        4.0\n    \"\"\"\n    if len(vector1) != len(vector2):\n        raise ValueError(\"Vectorii trebuie să aibă aceeași dimensiune\")\n\n    scalar_product = 0\n    for i in range(len(vector1)):\n        if vector1[i] != 0 and vector2[i] != 0:\n            scalar_product += vector1[i] * vector2[i]\n\n    return scalar_product\n\n\ndef test_problema_3():\n    assert (problema_3([1, 0, 2, 0, 3], [1, 2, 0, 3, 1]) == 4)\n    v1 = [1, 2, 3]\n    v2 = [4, 5, 6]\n    assert (problema_3(v1, v2) == 32.0)\n    try:\n        problema_3([0, 0], [0]) == ValueError\n    except ValueError as e:\n        assert str(e) == \"Vectorii nu au lungimi egale!\"\n    assert (problema_3([1, 2], [0, 0]) == 0)\n    print(\"Tests have passed!\")"
},
{
    "type": "String",
    "specifications": "Determine words that appear exactly once in a text\nparams: text (string)\nreturns: list of words that appear exactly once (list of strings)",
    "code": "def cuvinte_unice(text):\n    \"\"\"\n    Găsește cuvintele care apar exact o singură dată într-un text.\n\n    Args:\n        text (str): Textul de analizat.\n\n    Returns:\n        set: Set-ul de cuvinte unice.\n\n    Time Complexity:\n        O(n) - Parcurgem textul și construim un dicționar cu frecvențele cuvintelor.\n\n    Space Complexity:\n        O(n) - Spațiu suplimentar pentru dicționarul de frecvențe.\n\n    Example:\n        >>> cuvinte_unice(\"ana are ana are mere rosii ana\")\n        {'mere', 'rosii'}\n    \"\"\"\n    cuvinte = text.split()  # Descompunerea textului în cuvinte\n    frecvente = {}  # Dicționar pentru frecvențele cuvintelor\n\n    for cuvant in cuvinte:\n        frecvente[cuvant] = frecvente.get(cuvant, 0) + 1\n\n    cuvinte_unice = set()\n    for cuvant, frecventa in frecvente.items():\n        if frecventa == 1:\n            cuvinte_unice.add(cuvant)\n\n    return cuvinte_unice\n\ndef problema_4(text: str):\n    \"\"\"\n    Cautam cuvintele care se repeta o singura data\n    :param text: textul in care vom cauta cuvintele care apar o singura data in text\n    :time_complexity: Theta(N)\n    :space_complexity: Theta(M) , unde M este numarul de cuvinte ce nu se repeta\n    :return: list: lista cuvintelor ce nu se repeta\n\n    \"\"\"\n    words = text.split()\n    word_frequency = {}\n    # Theta(N)\n    for word in words:\n        if word in word_frequency:\n            word_frequency[word] = word_frequency.get(word) + 1\n        else:\n            word_frequency[word] = 1\n    non_repeating_word: list[str] = []\n    for word in word_frequency.keys():\n        if word_frequency[word] == 1:\n            non_repeating_word.append(word)\n    return non_repeating_word\n\ndef test_problema_4():\n    assert (problema_4(\"ana are ana are mere rosii ana\")==[\"mere\",\"rosii\"])\n    assert (problema_4(\"clara clara\")==[])\n    assert (problema_4(\"clara are\")==[\"clara\",\"are\"])\n    print(\"Tests have passed!\")"
},
{
    "type": "Array",
    "specifications": "Identify the repeated value in an array\nparams: array of integers\nreturns: repeated value (integer)",
    "code": "def problema_5(sequence:list)->int:\n    \"\"\"\n    Determina unica valoare care se repeta de doua ori\n    :param sequence: lista in care cautam valoarea care se repeta\n    :time_complexity: O(1)\n    :space_complexity: O(1)\n    :return: int: numarul care se repeta\n    \"\"\"\n    #calculam suma a n-1 ( unde n este lungimea vectorului) numere.\n    # Celalalt element care ramane din suma totala este elementul cautat\n    n=len(sequence)\n    sum_Gauss=((n-1)*n)//2\n    actual_sum=sum(sequence)\n    #number is the difference of them\n    return actual_sum-sum_Gauss\n\ndef find_duplicate_value(arr):\n    \"\"\"\n    Identifică valoarea care se repetă de două ori într-un șir.\n\n    Args:\n        arr (List[int]): Șirul de elemente.\n\n    Returns:\n        int: Valoarea care se repetă de două ori.\n\n    Time Complexity:\n        O(n) - Parcurgem șirul o singură dată.\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> find_duplicate_value([1, 2, 3, 4, 2])\n        2\n    \"\"\"\n    n = len(arr)\n    total_sum = n * (n - 1) // 2\n    real_sum = sum(arr)\n    return real_sum - total_sum\n\n\ndef test_problema_5():\n    assert(problema_5([1,2,3,4,2])==2)\n    assert(problema_5([1,2,3,4,3])==3)\n    assert(problema_5([1,1,2,3])==1)\n    print(\"Testele au rulat cu success!\")"
},
{
    "type": "Array",
    "specifications": "Determine the majority element in an array\nparams: array of integers\nreturns: majority element (integer)",
    "code": "def test_problema_6():\n    assert (problema_6([2,8,7,2,2,5,2,3,1,2,2])==2)\n    try:\n        problema_6([])\n    except ValueError as e:\n        assert str(e)==\"Sirul dat este gol!\"\n    assert(problema_6([1,1,1,2,2])==1)\n    print(\"Testele au trecut cu success\")\n\ndef problema_6(nums):\n    \"\"\"\n        Determina elementul majoritar (apare de mai mult de n/2 ori)\n    :param nums: sirul din care dorim sa determinam elementul majoritar\n    :time_complexity: Theta(n)\n    :space_complexity: O(n)\n    :return: elementul majoritar\n    \"\"\"\n    frequency = {}\n    if(len(nums)==0):\n        raise ValueError(\"Sirul dat este gol!\")\n    for number in nums:\n        if number not in frequency:\n            frequency[number] = 1\n        else:\n            frequency[number] += 1\n    n = len(nums)\n    for number in frequency.keys():\n        if (frequency[number] >= n/2):\n            return number\n\ndef find_majority(nums):\n    \"\"\"\n    Găsește elementul majoritar dintr-un șir de numere întregi.\n\n    Args:\n        nums (List[int]): Șirul de numere întregi.\n\n    Returns:\n        int: Elementul majoritar.\n\n    Time Complexity:\n        O(n) - Parcurgem șirul o singură dată.\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> find_majority([2, 8, 7, 2, 2, 5, 2, 3, 1, 2, 2])\n        2\n    \"\"\"\n    candidate = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n            count = 1\n        elif num == candidate:\n            count += 1\n        else:\n            count -= 1\n\n    return candidate"
},
{
    "type": "Array",
    "specifications": "Find the k-th largest element in an array\nparams: array of integers, integer k\nreturns: k-th largest element (integer)",
    "code": "def test_problema7():\n    assert (problema_7([7,4,6,3,9,1],2)==7)\n    try:\n        problema_7([],5)\n    except ValueError as e:\n        assert (str(e)==\"Lista are doar 0 elemente, astfel incat nu se poate descoperi al 5-lea cel mai mare element!\")\n    assert (problema_7([1,2,3,4],2)==3)\n    print(\"Tests ran successfully!\")\n\ndef problema_7(elements:list,k:int):\n    \"\"\"\n    Determin al k lea cel mai mare element al sirului elements\n    :param elements: sirul in care cautam cel de al k lea element\n    :param k: al catelea element cel mai mare il dorim\n    :time_complexity: O(nlogn)\n    :space_complexity: O(1)\n    :return: al k lea element cel mai mare din lista\n    \"\"\"\n    #cel mai usor e sa fie sortat si sa ii dau pe cel mai mare al k lea\n    if(len(elements)+1<k):\n        raise ValueError(f\"Lista are doar {len(elements)} elemente, astfel incat nu se poate descoperi al {k}-lea cel mai mare element!\")\n    return sorted(elements,reverse=True)[k-1]\n\ndef kth_largest(nums, k):\n    \"\"\"\n    Găsește al k-lea cel mai mare element dintr-un șir de numere.\n\n    Args:\n        nums (List[int]): Șirul de numere întregi.\n        k (int): Poziția dorită (k < len(nums)).\n\n    Returns:\n        int: Al k-lea cel mai mare element.\n\n    Time Complexity:\n        O(n) - Parcurgem șirul o singură dată.\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> kth_largest([7, 4, 6, 3, 9, 1], 2)\n        7\n    \"\"\"\n    if k <= 0 or k > len(nums):\n        raise ValueError(\"k trebuie să fie între 1 și lungimea șirului\")\n\n    def partition(left, right):\n        pivot = nums[right]\n        i = left\n        for j in range(left, right):\n            if nums[j] >= pivot:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n        nums[i], nums[right] = nums[right], nums[i]\n        return i\n\n    left, right = 0, len(nums) - 1\n    while True:\n        pivot_index = partition(left, right)\n        if pivot_index == k - 1:\n            return nums[pivot_index]\n        elif pivot_index < k - 1:\n            left = pivot_index + 1\n        else:\n            right = pivot_index - 1"
},
{
    "type": "Binary",
    "specifications": "Generate all binary numbers from 1 to n\nparams: integer n\nreturns: list of binary numbers (list of strings)",
    "code": "def problema_8_cu_conversie_directa(n):\n    \"\"\"\n        Genereaza toate numere cuprinse intre 1 si n\n    :param n: numarul pana la care se face conversia\n    :return: sirul de numere\n    :time_complexity:O(nlogn)\n    :space_complexity:O(1)\n    \"\"\"\n    return [bin(i)[2:] for i in range (1,n+1)]\n\ndef to_binary(n):\n    binary=\"\"\n    while(n):\n        if n%2==1:\n            binary+=\"1\"\n        else:\n            binary+=\"0\"\n        n/=2\n    return n\n\ndef problema_8(n):\n    binary_numbers = [\"1\"]\n    for i in range(2, n + 1):\n        binary_numbers.append(to_binary(i))\n    return binary_numbers\n\ndef test_problema_8():\n    print(problema_8_cu_conversie_directa(4))\n    assert(problema_8_cu_conversie_directa(4)==[\"1\",\"10\",\"11\",\"100\"])\n    assert(problema_8_cu_conversie_directa(3)==[\"1\",\"10\",\"11\"])\n\n\nfrom queue import Queue\n\ndef generate_binary_queue(n):\n    \"\"\"\n    Generează și afișează toate numerele în reprezentare binară de la 1 la n.\n\n    Args:\n        n (int): Numărul maxim.\n\n    Time Complexity:\n        O(n) - Parcurgem de la 1 la n și folosim o coadă.\n\n    Space Complexity:\n        O(n) - Spațiu suplimentar pentru coadă.\n\n    Example:\n        >>> generate_binary_queue(4)\n        1\n        10\n        11\n        100\n    \"\"\"\n    q = Queue()\n    q.put(\"1\")\n    numere=[]\n    while n > 0:\n        curr = q.get()\n        numere.append(curr)\n        q.put(curr + \"0\")\n        q.put(curr + \"1\")\n        n -= 1\n    return numere"
},
{
    "type": "Dynamic Programming",
    "specifications": "Calculate the sum of elements in submatrices identified by pairs of coordinates\nparams: matrix (list of lists), list of pairs of coordinates\nreturns: list of sums for each submatrix (list of integers)",
    "code": "def get_matrix(n, m) -> list[list[int]]:\n    \"\"\"\n        Obtinere matrice goala de n linii si m coloane\n    :param n: numar linii\n    :param m: numar coloane\n    :time_complexity: O(n)\n    :space_complexity: O(n*m)\n    :return: list[list[int]] -matrice de n linii si m coloane\n    \"\"\"\n    suma = []\n    for i in range(0, n):\n        row = m * [0]\n        suma.append(row)\n    return suma\n\n\ndef validate_pair(pair, array):\n    \"\"\"\n        Verifica daca o pereche de puncte ( (x1,y1) , (x2,y2) ) este valida in matricea array\n    :param pair: pereche de  puncte\n    :param array: matricea in care cautam\n    :time_complexity: O(1)\n    :space_complexity: O(1)\n    :return: True daca este o pereche valida!\n    :exception: ValueError - daca perechea nu este valida in matricea noastra\n    \"\"\"\n    left_corner = pair[0]\n    right_corner = pair[1]\n\n    if left_corner[0] < 0 or left_corner[1] > len(array[0]) - 1:\n        raise ValueError(f\"Incorrect pair {left_corner}\")\n    if right_corner[0] > len(array) or right_corner[1] > len(array[0]):\n        raise ValueError(f\"Incorrect pair {right_corner}\")\n    return True\n\n\ndef validate_pairs(pairs, array):\n    \"\"\"\n        Validam o lista de perechi de tipul ((x1,y1) , (x2,y2))\n    :param pairs: lista de perechi\n    :param array: matricea in care cautam validitatea lor\n    :time_complexity: O(n), unde n este numarul de perechi\n    :space_complexity: O(1)\n    :return: True - daca toate perechiile sunt valide\n    :exception: daca una din perechi nu este valida!\n    \"\"\"\n    for pair in pairs:\n        validate_pair(pair, array)\n    return True\n\n\ndef compare_points(pair1, pair2, pair_index):\n    \"\"\"\n        Compararea a doua perechi de tipul ((x1,y1), (x2,y2))\n    :param pair1: prima pereche\n    :param pair2: a doua pereche\n    :param pair_index: indexul coltului din matrice pe care il verificam. Avem colt stanga sus si colt dreapta jos.\n                        0-> indica coltul din stanga sus\n                        1-> indica coltul din dreapta jos\n    :time_complexity: O(1)\n    :space_complexity: O(1)\n    :return:  daca perechiile din coltul respectiv:\n                                            0-> sunt egale\n                                            >0-> pair1[index]>pair2[index]\n                                            <0->altfel\n    \"\"\"\n\n    if pair1[pair_index][0] != pair2[pair_index][0]:\n        return pair1[pair_index][0] - pair2[pair_index][0]\n    else:\n        return pair1[pair_index][1] - pair2[pair_index][2]\n\n\ndef get_sum_matrix_common(array, left_corner, right_corner):\n    \"\"\"\n        Determina sumele sub-matricelor matricii primite dintre punctele date .\n\n    :param array: matricea in care calculam suma submatricelor\n    :param left_corner: coltul din stanga sus\n    :param right_corner: coltul din dreapta jos\n    :time_complexity: O(n*m) unde n- numarul de linii la care trebuie sa calculam suma(\n    :return: o matrice cu sumele submatricelor matricei primite intre colturiile date\n    \"\"\"\n    li = left_corner[0]\n    lj = left_corner[1]\n    ri = right_corner[0]\n    rj = right_corner[1]\n    n = ri - li + 1  # numarul de linii dintre punctul cel mai de sus si cel mai de jos!\n    m = rj - lj + 1  # numarul de coloane dintre punctul cel mai de sus si cel mai de jos\n    suma = get_matrix(n, m)  # trebuie sa avem o matrice deja setata pe 9\n    suma[0][0] = array[li][lj]\n\n    for i in range(1, n):\n        suma[0][i] = suma[0][i - 1] + array[li][i + li]\n    for j in range(1, m):\n        suma[j][0] = suma[j - 1][0] + array[lj + j][lj]\n    for i in range(1, n):\n        for j in range(1, m):\n            suma[i][j] = array[i + li][j + lj] + suma[i - 1][j] + suma[i][j - 1] - suma[i - 1][j - 1]\n    return suma\n\n\ndef get_left_upper_corner(pairs):\n    \"\"\"\n        Determina punctul cel mai din stanga dintre toate perechiile primite\n    :param pairs: lista de perechi primita\n    :time_complexity: O(n*logn)\n    :space_complexity: O(1)\n    :return: (x,y) -> coltul cel mai din stanga\n    \"\"\"\n    return sorted(pairs, key=lambda x: compare_points(x, ((-1, -1), (-1, -1)), 0), reverse=False)[0][0]\n\n\ndef get_right_down_corner(pairs):\n    \"\"\"\n        Determina punctul cel mai din dreapta jos dintre toate perechiile primite\n        :param pairs: lista de perechi primita\n        :time_complexity: O(n* log n)\n        :space_complexity: O(1)\n        :return: (x,y) -> coltul cel mai din dreapta jos\n    \"\"\"\n    return sorted(pairs, key=lambda x: compare_points(x, ((0, 0), (0, 0)), 1), reverse=True)[0][1]\n\n\ndef get_sume_puncte(pairs, array):\n    \"\"\"\n        Determina sumele matricelor determinate de punctele dorite!\n    :param pairs: punctele la care trebuie aflata suma maricelor\n    :param array: matricea de unde trebuie sa afla suma sub matricelor\n    :time_complexity: O(n*m) unde n sunt distanta maxima dintre un cel mai mic punct X dintr o pereche de tipul (X,Y)\n                                                            si cel mai mare punct Y\n    :return: list- lista cu sumele sub-matricelor dintre punctele respective\n    \"\"\"\n    validate_pairs(pairs, array)\n    left_corner = get_left_upper_corner(pairs)\n    right_corner = get_right_down_corner(pairs)\n    sum_of_submatrixes = get_sum_matrix_common(array, left_corner, right_corner)\n    sum_for_pairs = []\n    lx = left_corner[0]\n    ly = left_corner[1]\n\n    for pair in pairs:\n        line_end = pair[1][0] - lx\n        column_end = pair[1][1] - ly\n        suma_pereche = sum_of_submatrixes[line_end][column_end]\n        line_beginning = pair[0][0] - lx\n        column_beginning = pair[0][1] - ly\n        if line_beginning != 0:\n            suma_pereche -= sum_of_submatrixes[line_beginning - 1][column_end]\n        if column_beginning != 0:\n            suma_pereche -= sum_of_submatrixes[line_end][column_beginning - 1]\n        if line_beginning != 0 and column_beginning != 0:\n            suma_pereche += sum_of_submatrixes[line_beginning - 1][column_beginning - 1]\n        sum_for_pairs.append(suma_pereche)\n    return sum_for_pairs\n\n\ndef calculate_submatrix_sum(matrix, pairs):\n    \"\"\"\n    Calculează suma elementelor din sub-matricele identificate de fiecare pereche de coordonate.\n\n    Args:\n        matrix (List[List[int]]): Matricea de întregi.\n        pairs (List[Tuple[int, int]]): Lista de perechi de coordonate.\n\n    Returns:\n        List[int]: Lista cu sumele corespunzătoare fiecărei perechi.\n\n    Time Complexity: O(n*m + k) - Parcurgem matricea și lista de perechi. ^eu zic ca a gresit si e n*m*k !!!!! Ai\n    dreptate, și îți mulțumesc pentru observație! Soluția mea are o complexitate de (O(n * m* k)), unde (n) este\n    numărul de linii, (m) este numărul de coloane și (k) este numărul de perechi de coordonate. Am revizuit codul și\n    am realizat că am făcut o eroare în evaluarea complexității. Îmi cer scuze pentru confuzie. Soluția ta este,\n    de fapt, eficientă și nu necesită (k). Mulțumesc încă o dată pentru atenție! 😊\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> matrix_exemplu = [[0, 2, 5, 4, 1],\n        ...                   [4, 8, 2, 3, 7],\n        ...                   [6, 3, 4, 6, 2],\n        ...                   [7, 3, 1, 8, 3],\n        ...                   [1, 5, 7, 9, 4]]\n        >>> pairs_exemplu = [(1, 1), (3, 3)]\n        >>> calculate_submatrix_sum(matrix_exemplu, pairs_exemplu)\n        [38, 44]\n    \"\"\"\n    result = []\n    for p, q in pairs:\n        r, s = pairs[p]\n        submatrix_sum = 0\n        for i in range(p, r + 1):\n            for j in range(q, s + 1):\n                submatrix_sum += matrix[i][j]\n        result.append(submatrix_sum)\n    return result\n\n\n# # Exemplu de utilizare\n# matrix_exemplu = [[0, 2, 5, 4, 1],\n#                   [4, 8, 2, 3, 7],\n#                   [6, 3, 4, 6, 2],\n#                   [7, 3, 1, 8, 3],\n#                   [1, 5, 7, 9, 4]]\n# pairs_exemplu = [(1, 1), (3, 3)]\n# print(calculate_submatrix_sum(matrix_exemplu, pairs_exemplu))\n# ^CRAPA\n\ndef problema_9(pairs, array: list[list]):\n    \"\"\"\n        Determina suma fiecarei sub-matrice determinate din lista de perechi \"pairs\"\n    :param pairs: lista de perechi\n    :param array: matricea data\n    :return: list- lista sumelor perechiilor de puncte\n    \"\"\"\n    sume = get_sume_puncte(pairs, array)\n    return sume\n\n\ndef test_problema_9():\n    array = [[0, 2, 5, 4, 1],\n             [4, 8, 2, 3, 7],\n             [6, 3, 4, 6, 2],\n             [7, 3, 1, 8, 3],\n             [1, 5, 7, 9, 4]]\n    pair1 = ((1, 1), (3, 3))\n    pair2 = ((2, 2), (4, 4))\n    pairs = [pair1, pair2]\n    sume = get_sume_puncte(pairs, array)\n    assert (sume[0] == 38)\n    assert (sume[1] == 44)\n    array2 = [[1, 2, 3, 4],\n              [5, 6, 7, 8],\n              [9, 10, 11, 12],\n              [13, 14, 15, 16]]\n    pairs2 = [((0, 0), (2, 2)), ((2, 2), (3, 3)), ((0, 1), (1, 3))]\n    sume2 = get_sume_puncte(pairs2, array2)\n    assert (sume2[0] == 54)\n    assert (sume2[1] == 54)\n    assert (sume2[2] == 30)\n    print(\"Tests have passed\")"
},
{
    "type": "Matrix",
    "specifications": "Identify the row with the most 1s in a binary matrix sorted by rows\nparams: binary matrix (list of lists)\nreturns: index of the row with the most 1s (integer)",
    "code": "def problema_10(array:list[list]):\n    \"\"\"\n        Determinare linia care are cele mai multe elemente egale cu 1\n    :param array: matricea in care cautam\n    :time_complexity: O(n)\n    :space_complexity: O(1)\n    :return: linia unde avem cei mai multi 1\n    \"\"\"\n    n=len(array)\n    m=len(array[0])\n    linie=0\n    i = 0\n    j = m-1\n    while(i<n):\n        while(j>=0):\n            if(array[i][j]==0):\n                break\n            else:\n                j-=1\n                linie=i\n        i+=1\n    return linie+1\n\ndef row_with_max_ones_naive(matrix):\n    \"\"\"\n    Găsește indexul liniei care conține cele mai multe elemente de 1 într-o matrice binară.\n\n    Args:\n        matrix (List[List[int]]): Matricea binară sortată crescător pe linii.\n\n    Returns:\n        int: Indexul liniei cu cele mai multe 1-uri.\n\n    Time Complexity:\n        O(m*n) - Parcurgem fiecare element din matrice.\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> matrix_exemplu = [[0, 0, 0, 1, 1],\n        ...                   [0, 1, 1, 1, 1],\n        ...                   [0, 0, 1, 1, 1]]\n        >>> row_with_max_ones_naive(matrix_exemplu)\n        1\n    \"\"\"\n    max_ones = 0\n    max_row_index = -1\n\n    for i, row in enumerate(matrix):\n        ones_count = row.count(1)\n        if ones_count > max_ones:\n            max_ones = ones_count\n            max_row_index = i\n\n    return max_row_index\n\ndef row_with_max_ones_binary_search(matrix):\n    \"\"\"\n    Găsește indexul liniei care conține cele mai multe elemente de 1 într-o matrice binară.\n\n    Args:\n        matrix (List[List[int]]): Matricea binară sortată crescător pe linii.\n\n    Returns:\n        int: Indexul liniei cu cele mai multe 1-uri.\n\n    Time Complexity:\n        O(m*log(n)) - Parcurgem fiecare linie și aplicăm căutarea binară.\n\n    Space Complexity:\n        O(1) - Nu folosim spațiu suplimentar.\n\n    Example:\n        >>> matrix_exemplu = [[0, 0, 0, 1, 1],\n        ...                   [0, 1, 1, 1, 1],\n        ...                   [0, 0, 1, 1, 1]]\n        >>> row_with_max_ones_binary_search(matrix_exemplu)\n        1\n    \"\"\"\n    max_ones = 0\n    max_row_index = -1\n\n    for i, row in enumerate(matrix):\n        index_of_first_one = row.index(1) if 1 in row else float('inf')\n        ones_count = len(row) - index_of_first_one\n        if ones_count > max_ones:\n            max_ones = ones_count\n            max_row_index = i\n\n    return max_row_index\n\n\ndef test_problema_10():\n    assert (problema_10([[1,1,1,1,1],[0,0,1,1,1],[0,0,1,1,1]])==1)\n    assert (problema_10([[0,0,0],[0,0,1],[0,1,1]])==3)\n    assert (problema_10([[0, 0], [0, 0], [0, 1],[0,0],[1,1]]) == 5)\n    print(\"Tests have passed\")"
}

  ]
